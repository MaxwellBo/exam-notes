\documentclass[landscape]{cheat}
\usepackage{amsmath}
\usepackage{listing}

\begin{document}
\footnotesize
\begin{multicols}{3}

\begin{center}
\Large{\underline{COMP3506 Cheat Sheet}} \\
\end{center}


%% START HERE
\section{Complexities}

\subsection{List of complexities, in sorted order}
\begin{description}
    \item[$O(1)$] Constant time.
    \item[$O(\log(n))$] Logarithmic time.
    \item[$O(\log(n)^c)$] Polylogarithmic time.
    \item[$O(n)$] Linear time.
    \item[$O(n^c)$] Polynomial time.
    \item[$O(c^n)$] Exponential time.
\end{description}

\subsection{Definitions of complexities}
\begin{align*}
    f(n) = O(g(n)) \rightarrow& g(n) \geq f(n) \\
    f(n) = \Theta(g(n)) \rightarrow& g(n) = f(n) \\
    f(n) = \Omega(g(n)) \rightarrow& g(n) \leq f(n)
\end{align*}

\subsection{Recurrence Relations}
\begin{align*}
    T(n) = T(\frac n 2) + O(1) \rightarrow& T(n) = O(\log n) \\
    T(n) = T(n - 1) + O(1) \rightarrow& T(n) = O(n) \\
    T(n) = 2 T(\frac n 2) + O(1) \rightarrow& T(n) = O(n) \\
    T(n) = T(n - 1) + O(n) \rightarrow& T(n) = O(n^2) \\
    T(n) = 2 T(\frac n 2) + O(n) \rightarrow& T(n) = O(n \log n)
\end{align*}

\section{Sorting Algorithms}
\begin{description}
    \item[Selection]
        \textsc{Scan} for the largest element.
        \textsc{Swap} largest element with last element.
        \textsc{Sort} elements 0 to $n-1$.
    \item[Merge]
        \textsc{Sort} each half of the list.
        \textsc{Merge} the two sorted halves together.
    \item[Quick]
        \textsc{Pick} a random pivot point.
        \textsc{Partition} the list, ensuring all elements are placed before the pivot iff they are less than it.
        \textsc{Sort} the list of elements larger than the pivot, and the list of elements smaller than it.
    \item[Bucket]
        \textsc{For} $i \in [0..l)$ where $l$ is the number of digits in the largest element.
        \textsc{Partition} the list elements into buckets, based off the value of their $i$th digit.
        \textsc{Combine} the buckets into a single list.
\end{description}

\section{Linear Structures}

\subsection{Abstract data types}
\begin{description}
    \item[Stack]
        first in last out,
        supports \textsc{push}, \textsc{pop}, \textsc{top} and \textsc{size}.
    \item[Queue]
        first in first out,
        supports \textsc{enqueue}, \textsc{dequeue}, \textsc{first} and \textsc{size}.
    \item[List]
        sequence of elements,
        supports \textsc{get}, \textsc{set}, \textsc{add}, \textsc{remove} and \textsc{size}.
    \item[Positional List]
        sequence of keys that are associated with elements,
        supports \textsc{before}, \textsc{after}, \textsc{first}, \textsc{last}, \textsc{size},
        \textsc{addFirst}, \textsc{addLast}, \textsc{addBefore}, \textsc{addAfter}, \textsc{set} and \textsc{remove}.
\end{description}

\subsection{Concrete data types}
\begin{description}
    \item[Linked List]
        \textbf{O(1)} iteration, and insertion / removal at the current index.
        \textbf{O(n)} indexing, and insertion / removal at a given index.
    \item[Array]
        \textbf{O(1)} iteration, indexing, and inserting / removal at the end of the list.
        \textbf{O(n)} insertion / removal at a given index.
\end{description}

\section{Trees}

\subsection{Abstract data types}
\begin{description}
    \item[Sorted Set]
        key store,
        supports \textsc{largest}, \textsc{smallest}, \textsc{before}, \textsc{after},
        \textsc{exists}, \textsc{add}, \textsc{remove} and \textsc{size}.
    \item[Sorted Map]
        key-value store,
        supports \textsc{largest}, \textsc{smallest}, \textsc{before}, \textsc{after},
        \textsc{get}, \textsc{put}, \textsc{remove} and \textsc{size}.
\end{description}

\subsection{Complexities}
\begin{description}
    \item[Largest] $O(\log n)$ average case, $O(n)$ worst case.
    \item[Smallest] $O(\log n)$ average case, $O(n)$ worst case.
    \item[Before] $O(\log n)$ average case, $O(n)$ worst case.
    \item[After] $O(\log n)$ average case, $O(n)$ worst case.
    \item[Exists / Get] $O(\log n)$ average case, $O(n)$ worst case.
    \item[Add / Put] $O(\log n)$ average case, $O(n)$ worst case.
    \item[Remove] $O(\log n)$ average case, $O(n)$ worst case.
    \item[Size] $O(1)$ worst case.
\end{description}

\subsection{Balancing}
The difference between average case and worst case depends on whether the tree is balanced.
Different algorithms exist to balance trees, based on different invariants.

\begin{description}
    \item[Red-Black]
        All nodes are coloured either red or black.
        \textsc{Root} is black.
        \textsc{Leafs} (nil) are black.
        \textsc{Red} nodes have two black children.
        \textsc{All} paths from the root to a leaf have the same number of black nodes.
    \item[AVL]
        At each node, the height of the left and right subtrees must differ by no more than one.
        If an insertion or deletion breaks this invariant at a node, balancing the first node with a broken invariant will balance the tree.
    \item[B]
        All keys are stored at the same depth, in leaf nodes.
        All nodes except the root are guaranteed to have between $0.4B$ and $B$ elements in them.
        To maintain this invariant, nodes can be split in two, or combined.
    \item[$(a,b)$]
        Like $B$ trees, except instead of $0.4B$ and $B$ its $a$ and $b$.
        Height is $\Omega(\log_b n)$ and $O(\log_a n)$.
        Must maintain $2 \leq a \leq \frac {b+1} 2$.
    \item[Splay]
        Keeps the most frequently used nodes close to the root of the tree.
        \textsc{Insert} operations move the new node to the root of the tree.
        \textsc{Successful} searches move the found node to the root of the tree.
        \textsc{Unsuccessful} searches move the last node involved in the search to the root of the tree.
        \textsc{Removals} move the parent of the removed item to the root of the tree.
\end{description}

\section{Heaps}
Also called a priority queue.
Stores a set of elements that are going to be accessed in sorted order.
Supports the following operations.

\begin{description}
    \item[Min] $\Theta(1)$.
    \item[RemoveMin] $\Theta(\log n)$.
    \item[Insert] $O(\log n)$ for binary heap, otherwise $\Theta(1)$.
    \item[Merge] $\Theta(n)$ for binary heap, $O(\log n)$ for binomial heap of $\Theta(1)$ for Fibonacci heap.
\end{description}

\subsection{Binary Heap}
A binary heap is a binary tree that satisfies the \textsc{heap order} property.
For every internal node $v$ except the root, $key(v) \geq key(parent(v))$.
A binary heap tree can have no gaps.

\end{multicols}
\end{document}
