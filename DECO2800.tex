\documentclass[landscape]{cheat}

\begin{document}
\footnotesize
\begin{multicols*}{3}

\begin{center}
\Large{\underline{DECO2800 Cheat Sheet}} \\
\end{center}

\section{Design Patterns}

\subsection{Singleton}
\begin{itemize}
    \item Static (global) reference to \texttt{self}.
    \item Static getter method that either returns the reference or instantiates it.
    \item Example uses include connection handles to servers, registries, managers.
\end{itemize}

\subsection{Observer}
\begin{itemize}
    \item One-to-many dependencies so that when the \textsc{one} changes, the \textsc{many} get notified.
    \item Used in things like GUIs and notification systems.
    \item Can lead to loose coupling between subject and observer.
\end{itemize}

\subsection{Composite}
\begin{itemize}
    \item Compose objects with recursive / tree-like hierarchies.
    \item Used in things like menu bars, graphics or abstract syntax trees.
    \item Can relate well to the visitor pattern.
\end{itemize}

\subsection{Visitor}
\begin{itemize}
    \item Separates the representation of an object structure from the representation of an operation to be performed on that structure.
    \item Allows for more code reuse, and simpler logic.
    \item Works well with the composite pattern.
\end{itemize}

\subsection{Mediator}
\begin{itemize}
    \item Creates a manager object that encapsulates the way that multiple child objects interact.
    \item Each child only needs to worry about its own state, and provides a simple interface that does not depend on other types.
    \item Manager object does not need to worry about internal workings of the child objects, and only cares about the interactions between them.
\end{itemize}

\subsection{Builder}
\begin{itemize}
    \item Separate the construction of an object from its running.
    \item Avoids excessive overloaded constructors.
\end{itemize}

\subsection{Proxy}
\begin{itemize}
    \item One class internally stores another, and provides a similar outward facing interface.
    \item This outer class is able to intercept messages as they go to the inner class, and verify them or take actions based on them.
\end{itemize}

\subsection{State}
\begin{itemize}
    \item An object's state is partitioned into a set of discrete states.
    \item The object can only be in one of these states at any time, and operations can move it from one state to another.
\end{itemize}

\subsection{Ghost}
\begin{itemize}
    \item A lazily loaded object that contains only enough information to bootstrap its initialisation when it is actually needed.
    \item Used for expensive resources that may not need to be initially loaded.
\end{itemize}

\subsection{MVC}
\begin{itemize}
    \item \textsc{Model} stores the data associated with the object, or the state.
    \item \textsc{View} holds a reference to the model, and renders it to an output.
    \item \textsc{Controller} receives feedback from the view, and updates the model as appropriate.
\end{itemize}

\section{Databases}

\begin{description}
    \item[JPA] Java Persistence Adaptor.
        This is an ORM, and allows you to access the data without writing SQL.
        Allows higher level abstractions and easier code.
    \item[JDBC] Java Data Base Connector.
        This is a low level sql-based API for connecting to databases.
        Allows more control and performance.
    \item[JDO] Java Data Objects.
        Focusses on modelling objects, and making them persistence.
        Same usage regardless of internal database technology, even supports NoSQL.
    \item[JDBI] Java Data Base Interfcae.
        Convenience library for creating SQL queries.
        Provides a balance between writing raw SQL and using an ORM.
\end{description}

\section{Class Diagrams}

\begin{tabular}{|p{0.3\textwidth}|}
\hline
    $<<$interface / abstract$>>$ \\
    ClassName \\
\hline
\begin{itemize}
    \item[-] privateAttribute: type
    \item[+] publicAttribute: type
    \item[\#] protectedAttribute: type
\end{itemize} \\ \hline
\begin{itemize}
    \item[+] publicFunction(param: type): type
    \item[+] publicFunction(param: type): type
\end{itemize} \\ \hline
\end{tabular}

\subsection{Relations Between Classes}
At each end of arrows are the number of each class involved. Either 0, 1 or *.
\begin{description}
    \item[Association]
        Simple arrow.
    \item[Aggregation]
        Simple arrow, with a hollow diamond at the tail.
        Stores a \textsc{has a} relationship.
    \item[Composition]
        Simple arrow, with a filled diamond at the tail.
        Stores a \textsc{has a} relationship, with \textsc{coincident life spans}.
    \item[Inheritance]
        Hollow head arrow.
        Stores the \textsc{inherits} relationship between a class and its superclass.
    \item[Subtyping]
        Hollow head, dotted arrow.
        Stores the \textsc{implements} relationship between a class and an interface.
\end{description}

\section{Sequence Diagrams}
\begin{itemize}
    \item Time flows \textsc{down} the page.
    \item Entities / objects are represented as \textsc{columns} along the page, with \textsc{labels} at the top.
    \item During a period of activity for an entity / object, it has a \textsc{box} in its column, otherwise it has a \textsc{dotted line} down the center.
    \item One entity sending a message to another is represented with a \textsc{solid arrow} between the two of them.
        This arrow is annotated with the message above it.
    \item A reply to a message is represented with a \textsc{dotted arrow} between the two of them.
        This arrow is annotated with the message above it.
    \item Alternative sequences are represented by drawing \textsc{boxes} around the branched section.
        The individual alternatives of the branch are separated by \textsc{dotted lines}.
        The condition of each branch is \textsc{written at the top} of its box, surrounded by $[]$.
        The top-left corner of the branched section has the word \textsc{alt} written in it.
\end{itemize}

\section{libGDX}
\begin{description}
    \item[Sprite] the image associated with an object.
        Stores colour, transformations, etc.
    \item[Texture] an image or section of image uploaded to the GPU.
    \item[Regions] a section within a texture.
    \item[Batching] gathering all draw calls into a single draw call to increase efficiency.
    \item[Scene Graph] the layout of a window, think of it like a tree.
    \item[Camera] a view matrix, used to represent where the player is in the world.
\end{description}

\end{multicols*}
\end{document}
